package organized.chaos;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.Objects;

/**
 *
 * @author Andres
 */
public class GraphPanel extends javax.swing.JPanel {
    
    private StoreGraph graph;
    private RouteList highlightedPath;

    /**
     * Creates new form GraphPanel
     */
    public GraphPanel() {
        initComponents();
    }

    public void setGraph(StoreGraph graph) {
        this.graph = graph;
    }

    public void setHighlightedPath(RouteList highlightedPath) {
        this.highlightedPath = highlightedPath;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        topPanel = new javax.swing.JPanel();
        titleLabel = new javax.swing.JLabel();
        bottomPanel = new javax.swing.JPanel();
        bottomFiller = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(32767, 0));
        returnButton = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        topPanel.setLayout(new java.awt.GridBagLayout());

        titleLabel.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        titleLabel.setText("Mapa de Rutas entre Almacenes");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.RELATIVE;
        gridBagConstraints.insets = new java.awt.Insets(20, 20, 20, 20);
        topPanel.add(titleLabel, gridBagConstraints);

        add(topPanel, java.awt.BorderLayout.NORTH);

        bottomPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(20, 20, 20, 20));
        bottomPanel.setOpaque(false);
        bottomPanel.setLayout(new java.awt.GridBagLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.weightx = 1.0;
        bottomPanel.add(bottomFiller, gridBagConstraints);

        returnButton.setText("Volver");
        returnButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                returnButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);
        bottomPanel.add(returnButton, gridBagConstraints);

        add(bottomPanel, java.awt.BorderLayout.SOUTH);
    }// </editor-fold>//GEN-END:initComponents

    private void returnButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_returnButtonActionPerformed
        App.getInstance().showOptionsPanel();
    }//GEN-LAST:event_returnButtonActionPerformed
    
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        if(graph == null || graph.getStores().getSize() == 0) {
            return;
        }
        
        List<Vertex> vertexes = new List<Vertex>(){
            @Override
            protected boolean compareKey(Vertex a, Object b) {
                return Objects.equals(a.store.getName(), b);
            }
        };
        
        final int maxCount = 6;
        final int xOffset = getSize().width/2, yOffset = getSize().height/2;
        final double thetaOffsetStep = Math.PI / 4;
        final double thetaStep = 2 * Math.PI / maxCount;
        final double radiusStep = 75;
        final int vertexRadius = 20;
        final int distanceRadius = 10;
        final int arrowRadius = 5;
        double thetaOffset = 0;
        double theta = thetaStep;
        double radius = 150;
        int count = 1;
        
        StoreList pending = new StoreList();
        Store first = graph.getStores().getFirst().getValue();
        pending.append(first);
        vertexes.append(new Vertex(first, (int) (radius * Math.cos(thetaOffset) + xOffset), (int) (radius * Math.sin(thetaOffset) + yOffset)));
        
        for (ListNode<Store> storeNode = pending.getFirst(); storeNode != null; storeNode = storeNode.getNext()) {
            Store store = storeNode.getValue();
            Vertex vertex = vertexes.find(store.getName());
            for (ListNode<Route> routeNode = store.getRoutes().getFirst(); routeNode != null; routeNode = routeNode.getNext()) {
                Route route = routeNode.getValue();
                if(!route.isBackwards()) {                    
                    Vertex targetVertex = vertexes.find(route.getStore().getName());
                    if(targetVertex == null) {
                        int x = (int) (radius * Math.cos(theta + thetaOffset) + xOffset);
                        int y = (int) (radius * Math.sin(theta + thetaOffset) + yOffset);
                        targetVertex = new Vertex(route.getStore(), x, y);
                        pending.append(route.getStore());
                        vertexes.append(targetVertex);
                        
                        if(++count == maxCount) {
                            count = 1;
                            radius += radiusStep;
                            theta = 0;
                            thetaOffset += thetaOffsetStep;
                        }
                        else {
                            theta += thetaStep;
                        }
                    }
                    double distanceX = vertex.x - targetVertex.x;
                    double distanceY = vertex.y - targetVertex.y;
                    double distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                    g.setColor(Color.BLACK);
                    if(highlightedPath != null && highlightedPath.getSize() > 1) {
                        System.out.println(highlightedPath.getSize());
                        for(ListNode<Route> highlightedRoute = highlightedPath.getFirst(); highlightedRoute.getNext() != null; highlightedRoute = highlightedRoute.getNext()) {
                            if(
                                highlightedRoute.getValue().getStore().getName().equals(store.getName()) &&
                                highlightedRoute.getNext().getValue().getStore().getName().equals(route.getStore().getName()) ||
                                highlightedRoute.getValue().getStore().getName().equals(route.getStore().getName()) &&
                                highlightedRoute.getNext().getValue().getStore().getName().equals(store.getName()) 
                            ) {
                                g.setColor(Color.BLUE);
                            }
                        }
                        System.out.println();
                    }
                    g.drawLine(vertex.x, vertex.y, targetVertex.x, targetVertex.y);
                    g.fillOval((int)((vertexRadius + arrowRadius) * distanceX / distance) + targetVertex.x - arrowRadius, (int)((vertexRadius + arrowRadius) * distanceY / distance) + targetVertex.y - arrowRadius, arrowRadius * 2, arrowRadius * 2);
                    g.setColor(Color.WHITE);
                    g.fillOval((vertex.x + targetVertex.x)/2 - distanceRadius, (vertex.y + targetVertex.y)/2 - distanceRadius, distanceRadius * 2, distanceRadius * 2);
                    g.setColor(Color.BLACK);
                    g.drawString("%d".formatted(route.getDistance()), (vertex.x + targetVertex.x)/2 - g.getFontMetrics().stringWidth("%d".formatted(route.getDistance()))/2, (vertex.y + targetVertex.y)/2 + g.getFontMetrics().getHeight()/3);
                }
            }
            pending.remove(store.getName());
        }
        
        for (ListNode<Vertex> node = vertexes.getFirst(); node != null; node = node.getNext()) {
            Vertex vertex = node.getValue();
            g.setColor(Color.WHITE);
            g.fillOval(vertex.x - vertexRadius, vertex.y - vertexRadius, vertexRadius * 2, vertexRadius * 2);
            g.setColor(Color.BLACK);
            g.drawOval(vertex.x - vertexRadius, vertex.y - vertexRadius, vertexRadius * 2, vertexRadius * 2);
            g.drawString(vertex.store.getName(), vertex.x - g.getFontMetrics().stringWidth(vertex.store.getName())/2, vertex.y + g.getFontMetrics().getHeight()/3);
        }
    }
    
    class Vertex {
        public Store store;
        public int x, y;

        public Vertex(Store store, int x, int y) {
            this.store = store;
            this.x = x;
            this.y = y;
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.Box.Filler bottomFiller;
    private javax.swing.JPanel bottomPanel;
    private javax.swing.JButton returnButton;
    private javax.swing.JLabel titleLabel;
    private javax.swing.JPanel topPanel;
    // End of variables declaration//GEN-END:variables
}
